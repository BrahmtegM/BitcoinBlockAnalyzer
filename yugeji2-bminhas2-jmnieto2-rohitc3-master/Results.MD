# CS225 Final Project: Bitcoin Transactions

## Team Members: Javier Nieto, Hugo Ji, Brahmteg Minhas, Rohit Chatterjee

Our project set out to analyze the bitcoin transactions displayed in a block of bitcoin in order to glean information about the movement of bitcoin and central bitcoin addresses. To do this, we implemented multiple algorithms on a set of publicly available block data from bitcoin. To run the entire program, input **./main**. 

## Creating the Graph
The first thing we implemented was a program to collect block data and insert it into an easily accessible structure that we can mold into a graph. We use a python script to scrape the bitcoin block into a .csv file. Within this .csv file, each line contains one transaction, ordered with the bitcoin sender, the transaction amount and the bitcoin receiver. Both bitcoin sender and receiver are labelled by a 25 - 34 character address which can contain almost all alphanumeric characters. 

From here, we parse through the file line by line. To convert the file into a graph, we have two distinct classes: a node and an edge. A node represents an address along with vectors for its incoming and outgoing bitcoin while an edge represents a transaction between two nodes. An important implementation detail is that we represent each edge as the inverse of the transaction amount. This allows us to prioritze higher transaction amounts in our shortest past traversal. Each line in the file creates a new edge and our program checks to see if the nodes referenced by this edge already exist. If not, we create them. We also store all edges and nodes in respective vectors for use in our later algorithms. This completes the formation of our graph. 

To test the creation of the graph, we first test the creation of specific random addresses that exist in the .csv file. Once these tests pass, we then take a tiny sample of connected edges and nodes and test to see if the net change in bitcoin due to transactions between these addresses are what we expect (see the test cases on lines 24 - 158 of tests.cpp). Once these tests pass, we are ready to move onto our more complicated algorithms. 

## Breadth First Search
The first algorithm we implemented was our Breadth First Search. This traverses through the entire graph starting at the first node in the node vector and then to all nodes connected to that node. Once all nodes either directly or indirectly connected to the node have been traversed, the algorithm goes down the node vector until it finds an untraversed node or a new portion of the graph. The nodes in order of traversal are added to a vector. This lets us identify all disjoint sets of connected nodes within the block. 

We test our Breadth First Search by taking a small sample of data and running the Breadth First Search on it. With this small sample, we can calculate the expected results by hand and then compare our BFS algorithm to this (See test cases on lines 159 - 196 of tests.cpp). To see the Breadth First Search of the entire dataset, run **./main --BFS**. Because our BFS does not differ much from that presented in lecture, the runtime complexity should be the same of O(V + E) where V is the number of nodes and E is the number of edges. 

## Dijkstra's Algorithm 
Next we implemented Dijkstra's Algorithm. We wanted to go with the standard implementation of Dijkstra's with weighted edges which is to prioritize lower weighted edges. Our goal with this algorithm was to estimate the *most likely* path that a satoshi would take to travel from a given sender to a given recipient. We assumed that the amount of a transaction is proportional to the probability that a satoshi belonging to the sender would move to that transaction's recipient instead of the sender's other recipients. Since we wanted this algorithm to prioritize bigger transactions, we set each edge weight to the inverse of the transaction amount. With this change, our algorithm can match the implementation provided in lecture and so there weren't any major issues implementing Dijkstra's algorithm. 

To test it, we took a similar approach to our test of the BFS algorithm by utilizing a small set of data so that we could calculate the shortest path by hand (see lines 197 - 263 of tests.cpp). We also utilize this algorithm within our Betweenness Centrality Algorithm so any errors here would have propogated to that algorithm. To see this algorithm on the entire dataset, run **./main --most-likely-path**

## Betweenness Centrality Algorithm 
Our betweenness centrality algorithm is our most important algorithm in that its result has the most obvious real world implications. We started by running Dijikstra's from every node, on every node. When running Dijikstra's we stored the path and if the node was in the path, it gained a centrality score. After we ran Dijkstra's on every node for every node, we then summed up each nodes score and ranked the nodes from most central to least central. The program then output the most central node. When running this algorithm initially, because of its high time complexity of O(n^3), the program took 45 minutes before we decided to optimize it. To optimize it, we ended up sampling the nodes, which is to say that we took a random set of n nodes to run Dijkstra's on instead of all nodes. This drastically decreased the runtime. Furthermore, the accuracy decrease from sampling is low as a central node will most likely be connected to more nodes and thus, more sampled nodes. Therefore, sampling was able to drastically decrease our runtime while keeping accuracy high. 

To test our betweenness centrality algorithm, we again created test cases with smaller datasets so we could calculate the result by hand and compare it to the result of the algorithm (see lines 264 - 366). However, the most important test was what our algorithm spit out when run over our entire data set. After using sampling, the algorithm output the address 1NDyJtNTjmwk5xPNhjgAMu4HDHigtobu1s. This is the address for Binance, one of the world's largest cryptocurrency exchanges! A result like this is exactly what we were hoping for and means that our algorithm, at least generally, works as expected. To run the betweenness centrality on the entire data set, type **./main --betweenness-centrality**

## Conclusion
Overall, our group met the goals that we set out to achieve initially. We traversed the graph using a Breath First Search, were able to find the most likely path between two nodes using Dijkstra's and were able to find the most central node using betweenness centrality. Furthermore, the output of our betweenness centrality algorithm can be very useful when comparing blockchain data as changes in the most central node over a period of time could indicate a change in public sentiment or a indicator of Bitcoins valuation or a companies sales. Further analysis on blockchain data can be used to find trends in Bitcoin and comparisons with other cryptocurrencies. While we met our original goals, the full potential of our program has not been realized! 
